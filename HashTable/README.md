# Хеш-таблица: практическое применение и оптимизация

В этой статье мы определим что такое хеш-таблица, исследуем некоторые аспекты, связанные с ее реализацией, применим данную структуру данных для решения практической задачи и попытаемся ее оптимизировать.

## Содержание 

[ВСТУПЛЕНИЕ](#вступление "Вступление")

[- Постановка простейшей задачи об именах и квартирах](#постановка-простейшей-задачи-об-именах-и-квартирах "Постановка простейшей задачи об именах и квартирах")

[- Создание хеш-таблицы для решения задачи в обратную сторону](#создание-хеш-таблицы-для-решения-задачи-в-обратную-сторону "Создание хеш-таблицы для решения задачи в обратную сторону")

[- Возникновение коллизий и их разрешение методом цепочек](#возникновение-коллизий-и-их-разрешение-методом-цепочек "Возникновение коллизий и их разрешение методом цепочек")

[- Как улучшить хеш-таблицу](#как-улучшить-хеш-таблицу "Как улучшить хеш-таблицу")

[ИССЛЕДОВАНИЕ ХЕШ-ФУНКЦИЙ](#исследование-хеш-функций "Исследование хеш-функций")

[- Основные характеристики хеш-функций](#основные-характеристики-хеш-функций "Основные характеристики хеш-функций")

[- Методика тестирования](#методика-тестирования "Методика тестирования")

[- Список исследуемых хеш-функций](#список-исследуемых-хеш-функций "Список исследуемых хеш-функций")

[- Результаты тестирования](#результаты-тестирования "Результаты тестирования")

[- Вывод](#вывод "Вывод")

[CОЗДАНИЕ АНГЛО-РУССКОГО ПЕРЕВОДЧИКА](#создание-англо-русского-переводчика "Создание англо-русского переводчика")

[- Постановка задачи переводчика](#постановка-задачи-переводчика "Постановка задачи переводчика")

[- Переводчик английских слов в русские](#переводчик-английских-слов-в-русские "Переводчик английских слов в русские")

[- Итог](#итог "Итог")

[ОПТИМИЗАЦИЯ](#оптимизация "Оптимизация")

[- Профилирование](#профилирование "Профилирование")

[- Рационализация словаря](#рационализация-словаря "Рационализация словаря")

[- Использование возможностей компилятора](#использование-возможностей-компилятора "Использование возможностей компилятора")

[- Применение SSE-инструкций](#применение-sse-инструкций "Применение SSE-инструкций")

[- Использование inline-функций](#использование-inline-функций "Использование inline-функций")

[- Переписывание фрагментов кода на языке ассемблера](#переписывание-фрагментов-кода-на-языке-ассемблера "Переписывание фрагментов кода на языке ассемблера")

[- Результаты](#результаты "Результаты")

[ЗАКЛЮЧЕНИЕ](#заключение "Заключение")

## Вступление

В программировании мы часто имеем необходимость хранить некоторые данные с возможностью обратиться к ним. К примеру, используя массивы, мы можем помещать в ячейки памяти некоторую информацию, которая затем доступна для прочтения при обращении к этим ячейкам по их адресам.

### Постановка простейшей задачи об именах и квартирах

Проиллюстрируем работу с массивом следующей несложной задачей. Пусть в некотором доме живут несколько ребят: Аня, Коля и Сережа. Семьи каждого из них имеют свои квартиры, у которых есть целочисленные положительные номера. Допустим, Аня живет в квартире №2, Коля - в квартире №7 и Сережа - квартире №5. В остальных квартирах живут незнаковые нам люди. Мы хотим иметь возможность по номеру квартиры узнать, кто там живет.

Для решения этой задачи мы можем завести массив строк, в N-ой ячейке которого будет храниться имя ребенка, который живет в квартире с номером N. Визуально структуру такого массива можно будет представить следующим образом:

![1_firstArr.png](img/1_firstArr.png)

Теперь, если мы хотим узнать, кто живет в какой-нибудь квартире, нам достаточно взять строку из ячейки с номером, равным номеру интересующей нас квартиры. В этой строке будет либо имя проживающего в ней,  либо она будет пустой, если в выбранной квартире живут незнакомцы.

Таким образом, построенный нами массив имеет информацию о парах *(номер квартиры - имя)* - зная первое, мы легко можем узнать второе. В общем случае в информатике такие пары имеют вид *(ключ - значение)*, где ключ - некоторый уникальный идентификатор, а значение - связанные с этим идентификатором данные. 

### Создание хеш-таблицы для решения задачи в обратную сторону

Но можно ли решить поставленную задачу в обратную сторону: построить такой массив, с помощью которого мы сможем по имени узнавать, в какой квартире он или она живет?

В данном случае мы сталкиваемся с проблемой: имена ребят нельзя использовать в качестве номеров ячеек массива, так как они являются наборами букв, а не натуральными числами. Однако мы можем использовать в качестве номеров ячеек не сами имена, а некоторую информацию о них, например, количество букв в каждом имени.

Давайте напишем функцию (назовем ее *hash*), которая принимает в качестве аргумента строку, а возвращает ее длину (например, *hash("Привет") = 6*). Теперь, если мы хотим узнать, где живет человек с некоторым именем *name*, мы вызовем *hash(name)* и полученное значение будем использовать как номер ячейки, в котором лежит номер квартиры человека с именем *name*. Теперь наш массив будет выглядеть следующем образом:

![2_secondArr.png](img/2_secondArr.png)

Таким образом, мы получили структуру данных, называемую **хеш-таблицей**. Она позволяет нам эффективно (то есть без необходимости полного перебора всего объема данных) получать некоторое значение (в данном случае номер квартиры) по ключу (в данном случае по имени). Функция *hash* в свою очередь называется **хеш-функцией**. Любая такая функция преобразует набор данных (в данном случае строку из букв) в некоторое конечное значение (в данном случае в натуральное число равное длине строки).

### Возникновение коллизий и их разрешение методом цепочек

Предположим, что мы познакомились еще с тремя ребятами. Их зовут Вова, Саша и Маша, а живут они в 6, 9 и 1 квартирах соответственно. Мы хотим добавить информацию о них в нашу хеш-таблицу, но есть одна проблема: длина имен Коли, Вовы, Саши и Машы равны, вследствие чего *hash("Коля")=hash("Вова")=hash("Саша ")=hash("Маша")=4*. Ситуации, когда хеш-функция выдает одно и то же значение при обработке разных ключей, называется **коллизия**.

Поскольку мы не можем положить более одного значения в одну ячейку массива, мы должны придумать способ разрешать коллизии. Существует много различных методов для решения этой задачи, но мы остановимся лишь на одном из них: разрешение коллизий с помощью **метода цепочек**.

Идея данного решения заключается в том, что вместо отдельных значений мы можем класть в ячейки массива набор пар *(ключ-значение)*. Набор может быть реализован разными способами, в том числе в виде обычного [связного списка](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA "Связный список (Википедия)"). После добавления новых имен в нашу хеш-таблицу с использованием списков, ее можно будет схематически представить следующим образом:

![3_thirdArr.png](img/3_thirdArr.png)

В качестве иллюстрации работы с такой структурой опишем последовательность действий, которая необходима чтобы узнать номер квартиры, в которой проживает, например, Маша:

1. Вызываем *hash("Маша")*, берем полученное значение (оно будет равно четырем), и рассматриваем соответственную ячейку массива (под номером четыре).
2. В четвертой ячейке находится список из нескольких пар *(ключ-значение)*. Начинаем их перебирать, пока не дойдем до пары, в которой ключем является "Маша".
3. Найдя пару с ключем "Маша", берем его значение. Им оказывается единица.

Таким образом мы получили информацию о том, что Маша живет в квартире №1.

### Как улучшить хеш-таблицу

Как вы наверное заметили, данные в хеш-таблице распределены неравномерно: пока одни ячейки пустуют, в других появляются значительные коллизии. В данном случае это связано в первую очередь с неудачным выбором хеш-функции, ведь многие имена имеют длины, принадлежащие узкому диапазону значений. Было бы значительно лучше, если бы при обработке имени учитывалось не только его длина, но и информация о буквах в нем, их расположение и т. д.

Но какую именно хеш-функцию лучше всего выбрать? Ответом на этот вопрос является исследование, которое будет подробно описано в следующей главе.

## Исследование хеш-функций

Целью данного исследования является тестирование различных хеш-функций для строк, содержащих английский текст, на большом объеме данных, получение их характеристических параметров и заключение об их пригодности для использования при решении реальных практических задач на основании информации, добытой в ходе работы.

### Основные характеристики хеш-функций

Прежде всего необходимо обозначить, какие характеристики являются наиболее критическими при исследовании работоспособности хеш-функций. В данной работе наибольшее внимание будет уделено следующим показателям: 

* **Дисперсия количества коллизий при разных размерах хеш-функций**. Отражает равномерность распределения коллизий в хеш-таблице при использовании данной хеш-функции. Является наиболее приоритетным параметром.
* **Максимальное и минимальное количество коллизий в одной ячейке.** Эти параметры помогают выявить участки с неравномерным распределением элементов в хеш-таблице, которые в силу особенностей расчета дисперсии не были отражены в ее показателях.
* **Время работы хеш-функции.** Это значение является ключевым при выборе из нескольких хеш-функций, обладающих близкими значениями дисперсии и других показателей равномерности.
* **Масштабируемость.** Относительная величина, отражающая способность функции сохранять свои свойства на массивах разной длинны. 

*Примечание:* Дисперсией в дальнейшем будем называть величину, рассчитываемую по следующей формуле:

`D = sqrt (V)`, 

где

`V = ((elems / length) - collisions) ^ 2`,

где `elems`  - количество элементов в хеш-таблице, `length` - длина массива, а `collisions` - количество коллизий в ячейке.

 Таким образом, значение дисперсии прямо пропорционально "неравномерности" распределения коллизий по ячейкам. В случае идеальной хеш функции значение дисперсии будет строго равно нулю. В случае малейшего отклонения от полной равномерности ее значение будет увеличиваться по мене увеличения разницы коллизий в различных ячейках. Таким образом, мы может использовать понятие дисперсии для характеристики качества работы хеш-функции на хеш-таблице с заданным массивом.

*Примечание:* Масштабируемостью в дальнейшем будем называть относительную величину, отражающую отношение динамики изменения дисперсии к динамике изменения размера массива, на котором происходит тестирование хеш-функции. Этот параметр рассчитывается следующим образом: 

`M = |sqrt(lenght[i]/lenght[i-1]) - sqrt(D[i]/D[i-1])|`,

где `lenght[i]` - длина массива на i-ой итерации тестирования, а `D[i]` -  дисперсия на  i-ой итерации тестирования. 

### Методика тестирования

Каждая функция по-очереди будет протестирована на множестве из 20 тысяч английских слов, наиболее часто встречающихся в английском языке. Полученные значения хеш-функций будут использоваться для получения числа коллизий, которые будут вызваны этими функциями на массивах длинной 7, 17, 29, 41, 101, 107, 1949 и 9973 элементов. 

На основании полученных данных будут построены диаграммы для визуализации результатов исследования и сделаны содержательные выводы.

### Список исследуемых хеш-функций

* **Константная хеш-функция**. Возвращает всегда фиксированное значение независимо от обрабатываемого ключа (в данном случае реализации ноль). Эзотерическая функция, которая заведомо неработоспособна, однако может использоваться для сравнения с остальными.
* **Хеш-функция длины строки.** Возвращает длину слова.
* **Хеш-функция первой буквы.** Возвращает ASCII-код первой буквы в слове.
* **Хеш-функция суммы кодов.** Возвращает сумму ASCII-кодов букв в слове. Как говорили в своей известной книге Керниган и Ритчи, *«Это не самый лучший алгоритм, но его достоинство заключаются в крайней простоте»*.
* **Битовый сдвиг влево.** Основан на битовом сдвиге влево и операции `xor`.
* **Хеш-функция суммы кодов с учетом позиции.** Возвращает сумму ASCII-кодов букв в слове, умноженных на номер буквы в слове.
* **Хеш Дженкинса (Jenkins hash).** Хеш-функция, разработанная Бобом Дженкинсом и впервые описанная в 1997 году.
* **DBJ2.** Хеш-функция, разработанная Даниэлем Юлиусом Бернштейном, который использует псевдоним "dbj".
* **SDBM.** Хеш-функция, созданная для открытой библиотеки New Database Manager.
* **Рандомная хеш-функция.** Авторская хеш-функция, делающая ряд математических операций, не обусловленных какими-либо строгими закономерностями или целями.
* **Хеш-функция 26-системы счисления.** Авторская хеш-функция, переводящая строку как 26-ичное число в десятичную систему счисления.

### Результаты тестирования

Рассмотрим результаты тестирования и охарактеризуем каждую функцию по отдельности. Далее идут названия функций, свод их показателей, графики распределения коллизий и краткое заключение.

#### Константная хеш-функция

|              Параметр               |      Значение       |
| :---------------------------------: | :-----------------: |
|              Дисперсия              |   **1924.3**20628   |
| Максимальные и минимальные коллизии | (20000 - 0) = 20000 |
|          Время работы (ms)          |          1          |
|          Масштабируемость           |    **0.09**5561     |

![4_GetConstantHash.png](img/4_GetConstantHash.png)

Очевидно, что данная хеш-функция не имеет практического смысла и заведомо сводит хеш-таблицу к списку с линейным временем поиска какого-либо элемента.

#### Хеш-функция длины строки

|              Параметр               |     Значение      |
| :---------------------------------: | :---------------: |
|              Дисперсия              |  **607.9**35322   |
| Максимальные и минимальные коллизии | (2943 - 0) = 2943 |
|          Время работы (ms)          |         8         |
|          Масштабируемость           |   **4.89**8221    |

![5_GetLengthHash.png](img/5_GetLengthHash.png)

Мы уже рассматривали эту хеш-функцию во вступлении, и теперь снова убеждаемся в том, что на практике она слабо применима, так как длины подавляющего большинства английских слов лежат в узком диапазоне.

#### Хеш-функция первой буквы

|              Параметр               |     Значение      |
| :---------------------------------: | :---------------: |
|              Дисперсия              |  **429.1**04208   |
| Максимальные и минимальные коллизии | (2110 - 0) = 2110 |
|          Время работы (ms)          |         2         |
|          Масштабируемость           |   **1.75**1431    |

![6_GetFirstLetterHash.png](img/6_GetFirstLetterHash.png)

Давайте рассмотрим распределение на массиве большего значения:

![7_GetFirstLetterHash.png](img/7_GetFirstLetterHash.png)

Мы снова получили неравномерное распределение, так как ASCII-коды английских букв лежат в интервале от 97 до 112. Учитывая также тот факт, что некоторые буквы встречаются чаще остальных в качестве первых букв слов (это хорошо демонстрирует первый график), на практике такая функция дает недопустимое количество коллизий.

#### Хеш-функция суммы кодов

|              Параметр               |    Значение    |
| :---------------------------------: | :------------: |
|              Дисперсия              | **170.0**52028 |
| Максимальные и минимальные коллизии | (551- 2) = 549 |
|          Время работы (ms)          |       18       |
|          Масштабируемость           | **14.62**4572  |

![8_GetSumHash.png](img/8_GetSumHash.png)

Более показательную картину мы может увидеть на большем массиве:

![9_GetSumHash.png](img/9_GetSumHash.png)

Как уже было сказано, ASCII-коды английских букв принадлежат диапазону, длина которого равна 26. Как следствие, при суммировании кодов букв на графике образуются характерные пики, которые соответствуют участкам с номерами, наиболее вероятно получающимися при суммировании нескольких букв. Понятно, что такое распределение является крайне не равномерным на массивах значительно длинны. 

#### Битовый сдвиг влево

|              Параметр               |    Значение     |
| :---------------------------------: | :-------------: |
|              Дисперсия              | **244.2**15262  |
| Максимальные и минимальные коллизии | (666 - 0) = 666 |
|          Время работы (ms)          |       10        |
|          Масштабируемость           |  **4.10**7862   |

![10_GetBitRotateHash.png](img/10_GetBitRotateHash.png)

Если ориентироваться исключительно на зрительный анализ графика, то может показаться, что он обладает удовлетворительной равномерностью распределения. Однако весьма высокая дисперсия говорит нам об обратном, в чем мы можем легко убедиться, снова взяв больший размер массива:

![11_GetBitRotateHash.png](img/11_GetBitRotateHash.png)

Мы видим довольно много хаотично расположенных пик. Коллизии в этих местах происходят слишком часто, что делает использование данной хеш-функции не очень рациональным.

#### Хеш-функция суммы кодов с учетом позиции

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **17.2**98659   |
| Максимальные и минимальные коллизии | (223 - 150) = 73 |
|          Время работы (ms)          |        30        |
|          Масштабируемость           |   **6.37**7997   |

![12_GetSumWithPlaceHash.png](img/12_GetSumWithPlaceHash.png)

Посмотрим на это распределение в большем масштабе:

![13_GetSumWithPlaceHash.png](img/13_GetSumWithPlaceHash.png)

Можно провести аналогию между полученным распределением и распределением, полученным при помощи хеш-функция суммы кодов. Однако в этом случае пики стали более пологими, а расстояние между ними значительно возросло. Тем не менее, вкупе с медленной скоростью работы, пригодность данной хеш-функции весьма сомнительна.

#### Хеш Дженкинса (Jenkins hash)

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **12.4**89646   |
| Максимальные и минимальные коллизии | (214 - 149) = 65 |
|          Время работы (ms)          |        24        |
|          Масштабируемость           |   **1.23**7076   |

![14_GetJenkinsHash.png](img/14_GetJenkinsHash.png)

Мы получили весьма хорошее распределение, которое сохраняется при переходе на большие размеры таблицы:

![15_GetJenkinsHash.png](img/15_GetJenkinsHash.png)

Данная хеш-функция известна как проверенный инструмент, который уже доказал свою свою эффективность в хешировании строк. Как мы видим, это первая функция из списка рассматриваемых функций, распределение которой не только имеет низкую дисперсию, но и ведет себя относительно стабильно на массивах разных размеров.

#### DBJ2

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **12.2**55483   |
| Максимальные и минимальные коллизии | (220 - 156) = 64 |
|          Время работы (ms)          |        20        |
|          Масштабируемость           |   **1.59**2371   |

![16_GetDJB2Hash.png](img/16_GetDJB2Hash.png)

И на большем массиве:

![17_GetDJB2Hash.png](img/17_GetDJB2Hash.png)

Характеристики данной функции по всем параметрам схожи с хеш-функцией Дженкинса, но в то же время незначительно эффективней по скорости исполнения. Мы можем запомнить данную функцию как возможный вариант для конечного выбора для применения.

#### SDBM

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **14.2**98900   |
| Максимальные и минимальные коллизии | (224 - 152) = 72 |
|          Время работы (ms)          |        22        |
|          Масштабируемость           |   **1.50**6558   |

![18_GetSBDMHash.png](img/18_GetSBDMHash.png)

Снова проверяем распределение на более объемной хеш-таблице:

![19_GetSBDMHash.png](img/19_GetSBDMHash.png)

Данная хеш-функция работает хорошо, но по характеристикам чуть уступает двум предыдущим.

#### Рандомная хеш-функция

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **12.4**86653   |
| Максимальные и минимальные коллизии | (227 - 151) = 76 |
|          Время работы (ms)          |        24        |
|          Масштабируемость           |   **3.14**3266   |

![20_GetRandomHash.png](img/20_GetRandomHash.png)

Как оказалось, на массиве небольшой длины рандомная хеш-функция дает весьма качественное распределение, что подтверждается низкой дисперсией. Однако при увеличении длины массива мы увидим области повышенной коллизии, которые можно зафиксировать даже невооруженным глазом:

![21_GetRandomHash.png](img/21_GetRandomHash.png)

График имеет несколько хаотичных, относительно пологих пик со случайными возрастаниями в некоторых ячейках. Понятно, что не обусловленная никакими математическими закономерностями хеш-функция ведет себя непредсказуемо и может быть применима далеко не всегда.

#### Хеш-функция 26-системы счисления

|              Параметр               |     Значение     |
| :---------------------------------: | :--------------: |
|              Дисперсия              |  **11.6**93542   |
| Максимальные и минимальные коллизии | (213 - 163) = 50 |
|          Время работы (ms)          |        26        |
|          Масштабируемость           |   **2.70**5723   |

![22_GetTuzmanHash.png](img/22_GetTuzmanHash.png)

Проверим, какое распределение получается на массиве большего размера:

![23_GetTuzmanHash.png](img/23_GetTuzmanHash.png)

В целом мы получаем равномерное распределение коллизий, особенно на массиве малой длины, где дисперсия имеет наименьшее значение среди представленных хеш-функций. Однако на большем массиве мы не получаем особого преимущества, а время работы данный хеш-функции выше чем у большинства рассмотренных до этого.

#### Сравнение хеш-функций по дисперсии на массиве фиксированной длины, масштабируемости и времени работы

Приведем единую таблицу, в которой будут приведены все ранее описанные данные с точностью до значений, не подверженных искажениям из-за каких-либо погрешностей. Жирным выделено лидерство данной функции в том или ином показателе (формата *"#_(место в данной колонке)"*).

| Номер |             Название функции             | Дисперсия на массиве из 107 элементов | Время работы (в ms) при обработке 20 тысяч слов с точностью до 1 ms | Масштабируемость |
| :---: | :--------------------------------------: | :-----------------------------------: | :----------------------------------------------------------: | :--------------: |
|   1   |         Константная хеш-функция          |                1924.3                 |                         **1 (#_1)**                          |  **0.09 (#_1)**  |
|   2   |         Хеш-функция длины строки         |                 607.9                 |                         **8 (#_3)**                          |       4.89       |
|   3   |         Хеш-функция первой буквы         |                 429.1                 |                         **2 (#_2)**                          |       1.75       |
|   4   |         Хеш-функция суммы кодов          |                 170.0                 |                              18                              |      14.62       |
|   5   |           Битовый сдвиг влево            |                 244.2                 |                              10                              |       4.10       |
|   6   | Хеш-функция суммы кодов с учетом позиции |                 17.2                  |                              30                              |       6.37       |
|   7   |              Хеш Дженкинса               |            **12.4 (#_3)**             |                              24                              |  **1.23 (#_2)**  |
|   8   |                   DBJ2                   |            **12.2 (#_2)**             |                              20                              |       1.59       |
|   9   |                   SDBM                   |                 14.2                  |                              22                              |  **1.50 (#_3)**  |
|  10   |          Рандомная хеш-функция           |            **12.4 (#_3)**             |                              24                              |       3.14       |
|  11   |     Хеш-функция 26-системы счисления     |            **11.6 (#_1)**             |                              26                              |       2.70       |

Для более наглядного сравнения представим эти данные в виде диаграмм.

Дисперсия на массиве из 107 элементов:

![24_compare.png](img/24_compare.png)

Время работы (в ms) при обработке 20 тысяч слов с точностью до 1 ms:

![25_compare.png](img/25_compare.png)

Минимальное (синий цвет) и максимальное (оранжевый цвет) количество коллизий на массиве из 107 элементов.

![26_compare.png](img/26_compare.png)

Масштабируемость:

![27_compare.png](img/27_compare.png)

### Вывод 

Функцией из рассматриваемого списка, лучше всего подходящей для хеширования английских слов, можно назвать **DBJ2**. Несмотря на то, что мы исследовали некоторые другие функции (например, SDBM и хеш Дженкинса), обладающие схожими показателями, DBJ2 имеет наименьшее время работы среди них, что является одним из самых приоритетных критериев. Кроме того, мы можем быть уверены в стабильности данной хеш-функции благодаря низкой масштабируемости, что позволяет нам более безопасно применять ее в нашем проекте.

## Создание англо-русского переводчика

Теперь применим разработанную структуру данных для решения практической задачи.

### Постановка задачи переводчика

Автоматический переводчик - это компьютерная программа, способная отвечать на запросы в виде слов, возвращая их перевод на некоторый язык. Поскольку читатели данной статьи знакомы с русским языком, мы в качестве примера рассмотрим переводчик с английского на русский.

Для создания переводчика мы задействуем описанную ранее хеш-таблицу, работающую с парами *(ключ - значение)*, где в качестве ключа выступает английское слово, а в качестве значения - русское слово, имеющее схожее значение с английским. Нам необходимо реализовать функцию, способную искать перевод каждого конкретного слова, а зачем с помощью нее мы сможем обрабатывать разнообразные крупные тексты.

**Примечание: мы не ставим перед собой цели получить лингвистически идеальный перевод. Наша задача состоит в написании программы, способной давать ответы на запросы с допущением большой погрешности, в том числе пренебрежением формами слов.**

### Переводчик английских слов в русские

Перед осуществлением перевода необходимо инициализировать и наполнить информацией хеш-таблицу. Для этого возьмем базу данных, содержащей перевод большинства английских слов на русские, в удобном для парсинга (вычленения нужной информации) виде. Пройдем по базе данных от начала до конца, высчитывая хеш от каждого английского слова и помещая в соответствующие связные списки пары английских и русских слов. После завершения построения хеш-таблицы она готова к ответу на запросы.

Теперь при каждом обращении к переводчику мы будем брать переданную в качестве аргумента строку, считать ее хеш, переходить в соответствующий список и проходить по нему до поиска нужной пары. Но при попытке переводить некоторые слова мы сталкиваемся со следующей лингвистической проблемой: обычно в качестве баз данных выступают словари, которые содержат далеко не все возможные формы слова. Например, чаще всего мы можем найти инфинитивы глаголов, но глаголы в различных временах зачастую могут отсутствовать. В результате при попытке обработать запрос с неизвестным словом мы будем доходить до конца списка, не найдя нужного результата.

Чтобы решить эту проблему мы попытаемся изменять форму слова, если его не удалось найти в хеш-таблице. Чаще всего в английском языке формы слов образованны двумя основными морфемами:

* Префикс
* Окончание

Соответственно, мы будем производить изменения формы слова по двум следующим алгоритмам:

* Удаление по одной букве с начала слова и попытки найти перевод по полученной строке до тех пор, пока не будет найден результат или пока не будет удалена половина букв в исходном слове
* Удаление по одной букве с конца слова и попытки найти перевод по полученной строке до тех пор, пока не будет найден результат или пока не будет удалена половина букв в исходном слове

Теперь мы сможем искать многие слова, которые до этого не приводили бы к поиску их перевода. Например, теперь `reading` будет преобразовываться в `read` и переводиться как `читать`, а `rewriting` в `writing` с переводом `письмо`.

Но как поступить, если эти два алгоритма не помогли нам найти слово, отсутствующее в хеш-таблице? При переводе полноценных текстов такая ситуация не является редкостью, ведь вряд ли в обычном словаре содержаться имена, названия и другие имена собственные. Обычно такие слова переводят фонетически, то есть создают такое слово на переводимом языке, чтобы при его произношении его звучание было как можно более похожим на звучание при произношении на изначальном языке. Мы поступим аналогично и напишем примитивную функцию, которая будет сопоставлять каждой английской букве ее ближайший "аналог" из русского языка, который в большинстве слов дает тот же звук, что и английская буква в обычной речи. Например, буква `f ` превратиться в `ф`, а `p` в `п`.

### Итог 

Таким образом, мы получили переводчик английских слов на русские, который можно использовать для пословного перевода текстов, веб-страниц и любых других документов. Например, обработка строки `Boy  eats cake in Gonalanovka` с помощью нашей программы приведет к `Мальчик есть пирог в гоналановка`.

Однако мы можем заменить, что при обработке больших объёмах данных время работы программы может сильно возрастать. Что приводит к замедлению программы и как мы можем с этим бороться? Ответом на эти вопросы является следующая глава. 

## Оптимизация

В этой главе мы определим какие части программы требуют наибольшее время для выполнения и рассмотрим различные способы их оптимизации.

### Профилирование 

Прежде всего нам нужно собрать информацию о времени работы различных компонент нашей программы. Замерим время работы основных функций, связанных с хеш-функцией и ее работой (другие части программы, такие как, например, считывание и запись текста в файл, брать во внимание не будем). При этом мы не будем рассматривать функции, связанные с генерацией структуры хеш-таблицы. Результаты профилирования представлены  таблице ниже:

| Название функции в коде | Время работы при обработке текста в 10000 строк (в ms) |           Краткое описание предназначения функции            |
| :---------------------: | :----------------------------------------------------: | :----------------------------------------------------------: |
|        FindByKey        |                          208                           | Находит в хеш-таблице перевод переданного в качестве аргумента слова |
|         strlen          |                           18                           |                     Находит длину строки                     |
|          DBJ2           |                           90                           |                         Хеш-функция                          |
|     FindInListByKey     |                          791                           | Находит в списке перевод переданного в качестве аргумента слова |
|         strcmp          |                          291                           |                Проверяет равны ли две строки                 |

### Рационализация словаря

Многие словари, доступные для скачивания в открытых источниках, содержат в себе список слов, отсортированных по алфавиту. Если мы используем подобный словарь для генерации хеш-таблицы, то в списках слова тоже окажутся в алфавитном порядке. Как следствие, те или иные слова будут требовать разного времени, чтобы их найти. 

Стоит заметить, что некоторые часто используемые слова английского языка находятся очень низко в отсортированном по алфавиту списке. Например, артикль `the` является самым популярным в английской речи, но при этим находится почти в самом конце своего списка. Необходимость постоянно совершать длительный поиск этого и других частых слов приводит к заметному снижению производительности.

Решением данной проблемы является использование специфицированного словаря, в котором слова расположены не по алфавиту, а по частоте использования. Для разных типов текста эти словари будут разными, поскольку в художественной литературе, публицистике, интернете, разговорной речи и других жизненных областях преобладают разные слова. В случае нашей хеш-таблицы мы возьмем наиболее используемые выражения в интернете.

Замерим среднее время поиска десяти тысячи слов в при переводе некоторой интернет-статьи с использованием старого и нового словарей. Результаты представлены в следующей таблице:

|           Тип словаря           | Время поиска 10000 слов (в ms) | Процентное соотношение | Процентное ускорение |
| :-----------------------------: | :----------------------------: | :--------------------: | :------------------: |
|   Отсортированный по алфавиту   |              791               |          100%          |          0%          |
| Отсортированный по частоте слов |              488               |          61%           |         39%          |

При этом данное значение может сильно различаться в зависимости от переводимого текста. 

### Использование возможностей компилятора

Многие современные компиляторы оснащены встроенными инструментами оптимизации, способными  повысить быстродействие программы. Кратко пройдемся по основным уровням оптимизаций, представленным GCC компилятором:

* `O0` Этот уровень отключает оптимизацию полностью и является уровнем по умолчанию.
* `O1` Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции.
* `O2` Компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции. На этом уровне могут быть использованы SSE и AVX.
* `O3`  Это наибольший возможный уровень оптимизации. Включает оптимизации, являющейся дорогостоящей с точки зрения времени компиляции и потребления памяти. Компиляция на этом уроне не является гарантированным способом повышения производительности, и на самом деле во многих случаях может привести к замедлению системы из-за больших двоичных файлов и увеличения потребления памяти. Не рекомендуется к использованию без веской надобности, так как может приводить к ошибкам в работе программы.

Попробуем поочередно применить данные опции при компилировании и замерить общее время работы программы при переводе некоторого объема текста. Результаты измерений представлены в следующей таблице:

| Тип оптимизации | Время работы (в ms) | Процентное соотношение | Процентное ускорение |
| :-------------: | :-----------------: | :--------------------: | :------------------: |
|       О0        |         63          |          100%          |          0%          |
|       О1        |         54          |          86%           |         14%          |
|       О2        |         51          |          81%           |         19%          |
|       О3        |         51          |          81%           |         19%          |

Так как `O3` может приводить к некорректной работе программы, на практике мы будем использовать `O2`.

### Применение SSE-инструкций

SSE-инструкции (*Streaming SIMD Extensions*) - расширение инструкций процессора для потоковой обработки в режиме SIMD (*Single Instruction Multiple Data*), то есть когда требуется применять однотипные операции к потоку данных. 

Одной из функций нашей программы, которая может быть переписана с использованием SSE-инструкций, является компаратор для сравнения строк.  Мы можем представить строки как 32-байтное число и сравнивать их единственной командой.

Таким образом, мы получаем следующую функцию:

```c
bool FastStrcmp (char* first, char* second) {

    if (first == NULL || second == NULL) {
        return false;
    }

    int compareResult = _mm256_movemask_epi8 (
            _mm256_cmpeq_epi8 (_mm256_loadu_si256 ((__m256i*)first),
                               _mm256_loadu_si256 ((__m256i*)second))
    										 );

    return compareResult == -1;
}
```

Измерим время работы функций стандартной библиотеки и нашей новой функцией с SSE-инструкциями. Результаты измерений представлены в следующей таблице:

|                 Функция                 | Время сравнения 10000 слов (в ms) | Процентное соотношение | Процентное ускорение |
| :-------------------------------------: | :-------------------------------: | :--------------------: | :------------------: |
|           Библиотечная strcmp           |                291                |          100%          |          0%          |
| Компаратор с применением SSE-инструкций |                250                |          86%           |         14%          |

### Использование inline-функций

Inline-функция - это такая функция, чье тело подставляется в каждую точ­ку вызова, вместо того, чтобы генерировать код вызова. Использование такой постановки имеет как положительные стороны, так и отрицательные. В частности, код с inline-функциями работает быстрее, так как в нем меньше обращений и передачи аргументов вызываемым функциям, но с другой стороны исполняемая программа становится от этого больше по размеру.

В случае многократных вызовов коротких функций имеет смысл применять их как inline-функции. Примером такой функции является компаратор, которым мы переписали на предыдущем шаге.

Сам по себе компаратор не станет работать быстрее, но времени на его вызов будет требоваться значительно меньше, благодаря чему ускорится вызывающая его функция. Замерим ее работу с и без использования inline-подстановки:

| Inline-подстановка | Время сравнения 10000 слов (в ms) | Процентное соотношение | Процентное ускорение |
| :----------------: | :-------------------------------: | :--------------------: | :------------------: |
|  Не используется   |                250                |          100%          |          0%          |
|    Используется    |                237                |          95%           |          5%          |

### Переписывание фрагментов кода на языке ассемблера

Современные компиляторы способны производить глубокий анализ кода и его качественную оптимизацию, однако существуют ситуации, в которых программист способен написать более оптимальный код на языке ассемблера, нежели тот, что сгенерирован машиной. 

Переписывать код на ассемблере вручную имеет смысл в ситуациях, когда это не слишком трудозатратый процесс, приводящий к заметному улучшению производительности (например, если переписанная функция многократно вызывается). Самой часто вызываемой функцией нашего переводчика является хеш-функция, работа которой начинается во время создания хеш-таблицы и продолжается на протяжении работы всей программы. Кроме того, ее переписывание не занимает много человеческого ресурса, и именно поэтому мы выберем ее для переписывания на ассемблер.

Теперь код нашей функции выглядит следующим образом:

```assembly
hash_t FastGetDJB2Hash (input_t* data) {

    assert (data);

    hash_t hash;

    asm(".intel_syntax noprefix \n"
        "mov rax, 5381          \n"  //Hash
        "mov rbx, %1            \n"  //Pointer
        "HANDLING_LOOP:         \n"
        "cmp byte ptr [rbx], 1  \n"
        "je END_OF_HANDLING     \n"
        "shl rax, 6             \n"
        "add rax, [rbx]         \n"
        "inc rbx                \n"
        "jmp HANDLING_LOOP      \n"
        "END_OF_HANDLING:       \n"
        "mov %0, rax            \n"
        ".att_syntax            \n"
        :"=r"(hash)             // список выходных параметров.
        :"r"(data)              // список входных параметров.
        :"rax", "rbx"           // список разрушаемых регистров.
    );

    return hash;
}
```

Теперь сравним скорости функций, составленных человеком и компилятором. Результаты измерений представлены в следующей таблице:

|           Функция           | Время хеширования 10000 слов (в ms) | Процентное соотношение | Процентное ускорение |
| :-------------------------: | :---------------------------------: | :--------------------: | :------------------: |
| Компилируемая автоматически |                 90                  |          100%          |          0%          |
|    Написанная человеком     |                 80                  |          89%           |         11%          |

### Результаты

Мы рассмотрели основные методы оптимизации программы и теперь пора подвести итоги. Каждое наше улучшение уменьшало время выполнения конкретных функций программы, а вместе с ними и всей программы в целом. Итоговые сравнительные результаты можно увидеть в следующей таблице:

|           Примененный метод оптимизации           | Оптимизированный объект | Процент улучшения производительности |
| :-----------------------------------------------: | :---------------------: | :----------------------------------: |
|              Рационализация словаря               | Функция FindInListByKey |                 39%                  |
|      Использование возможностей компилятора       |      Вся программа      |                 19%                  |
|             Применение SSE-инструкций             |     Функция Strcmp      |                 14%                  |
|           Использование inline-функций            |     Функция Strcmp      |                  %5                  |
| Переписывание фрагментов кода на языке ассемблера |    Хеш-функция DJB2     |                 11%                  |

Итоговое улучшение производительности всей программы:

|           Состояние            | Время отработки 10000 слов (в ms) | Процентное соотношение | Процентное ускорение |
| :----------------------------: | :-------------------------------: | :--------------------: | :------------------: |
|        Без оптимизаций         |                63                 |          100%          |          0%          |
| С применением всех оптимизаций |                45                 |          71%           |         29%          |

## Заключение

В ходе проделанной работы мы описали структуру данных под названием `хеш-таблица`, применили ее для создания англо-русского переводчика и использовали различные методы для его оптимизации по времени, добившись ускорения на 29%. 

Автор: Тузман Александр Михайлович

Почта: tuzman.am@phystech.edu

ВКонтакте: https://vk.com/id479958357
